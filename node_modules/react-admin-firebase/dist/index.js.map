{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/misc/logger.ts","../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/pathHelper.ts","../src/providers/database/ResourceManager.ts","../src/misc/timestamp-parser.ts","../src/providers/database/FirebaseClient.ts","../src/misc/file-parser.ts","../src/providers/DataProvider.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\n\n// UTILS\n\nexport class SimpleLogger {\n  private title = \"ðŸ”¥r-a-f: \";\n\n  isEnabled() {\n    return !!localStorage.getItem('LOGGING_ENABLED');\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.log.bind(console, this.title);\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.warn.bind(console, this.title);\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return (...any) => {};\n    }\n    const boundLogFn: (...any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n\nconst logger = new SimpleLogger();\n\nexport function CheckLogging(config: {}, options: RAFirebaseOptions) {\n  const logSignalDeprecated = config && config[\"debug\"];\n  const logSignal = options.logging;\n  if (logSignalDeprecated || logSignal) {\n    localStorage.setItem('LOGGING_ENABLED', 'true')\n  } else {\n    localStorage.removeItem('LOGGING_ENABLED')\n  }\n}\n\nexport const log = logger.log;\nexport const logWarn = logger.warn;\nexport const logError = logger.error;\n","import { isEmpty, get } from \"lodash\";\nimport { SearchObj, getFieldReferences } from \"./objectFlatten\";\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: \"asc\" | \"desc\"\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = a[field];\n    const rawB = b[field];\n    const isAsc = dir === \"asc\";\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA == \"string\" && typeof rawB == \"string\";\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields: { [field: string]: string | number | boolean }\n): Array<{}> {\n  if (isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce(\n      (prev, curr) =>\n        doesRowMatch(row, curr.searchField, curr.searchValue) && prev,\n      true\n    )\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  let searchThis = row[searchField];\n  const isDeepField = searchField.includes(\".\");\n  if (isDeepField) {\n    searchThis = get(row, searchField);\n  }\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === \"string\";\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === \"boolean\" || typeof searchValue === \"number\";\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  return false;\n}\n","export interface SearchObj {\n  searchField: string;\n  searchValue: number | string | boolean;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | number | string | boolean\n): SearchObj[] {\n  const isFalsey = !value;\n  const isSimple = isFalsey;\n  typeof value === \"string\" ||\n    typeof value === \"number\" ||\n    typeof value === \"boolean\";\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as number | string | boolean,\n      },\n    ];\n  }\n  const tree = {};\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = function (obj: {}, path) {\n    path = path || \"\";\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj[key];\n        const currentPath = !!path ? path + \".\" + key : key;\n        const isWalkable =\n          typeof objVal === \"object\" || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","import path from 'path-browserify'\n\nexport function getAbsolutePath(rootRef: string, relativePath: string): string {\n  if (!rootRef) {\n    return relativePath;\n  }\n  if (!relativePath) {\n    throw new Error('Resource name must be a string of length greater than 0 characters');\n  }\n  const withSlashes = path.join('/', rootRef, '/', relativePath, '/');\n  const slashCount = withSlashes.split(\"/\").length - 1\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\" not a \"collection\"\ne.g. /collection/document/ or /collection/document/collection/document/`);\n  }\n  const withOutSlashes = withSlashes.slice(1, -1);\n  return withOutSlashes;\n}\n\nexport function joinPaths(path1, path2) {\n  return path.join(path1, path2);\n}","// Firebase types\nimport {\n  CollectionReference,\n  QueryDocumentSnapshot,\n  FirebaseFirestore\n} from \"@firebase/firestore-types\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { User } from \"@firebase/auth-types\";\nimport { log, getAbsolutePath, messageTypes, logError, parseAllDatesDoc } from \"../../misc\";\n\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: CollectionReference;\n  list: Array<{}>;\n}\n\nexport class ResourceManager {\n  private resources: {\n    [resourceName: string]: IResource;\n  } = {};\n\n  private db: FirebaseFirestore;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions\n  ) {\n    this.db = fireWrapper.db();\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log(\"resourceManager.TryGetResourcePromise\", {\n      relativePath,\n      collectionQuery\n    });\n    await this.initPath(relativePath, collectionQuery);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType\n  ) {\n    log(\"resourceManager.RefreshResource\", { relativePath, collectionQuery });\n    await this.initPath(relativePath, collectionQuery);\n    const resource = this.resources[relativePath];\n\n    const collection = resource.collection;\n    const query = this.applyQuery(collection, collectionQuery);\n    const newDocs = await query.get();\n\n    resource.list = newDocs.docs.map(doc => this.parseFireStoreDocument(doc));\n    log(\"resourceManager.RefreshResource\", {\n      newDocs,\n      resource,\n      collectionPath: collection.path\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n    const docSnap = await resource.collection.doc(docId).get();\n    if (!docSnap.exists) {\n      throw new Error(\"react-admin-firebase: No id found matching: \" + docId);\n    }\n    const result = this.parseFireStoreDocument(docSnap);\n    log(\"resourceManager.GetSingleDoc\", {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result\n    });\n    return result;\n  }\n\n  private async initPath(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log(\"resourceManager.initPath()\", {\n      absolutePath,\n      hasBeenInited\n    });\n    if (hasBeenInited) {\n      log(\"resourceManager.initPath() has been initialized already...\");\n      return;\n    }\n    const collection = this.db.collection(absolutePath);\n    const list: Array<{}> = [];\n    const resource: IResource = {\n      collection: collection,\n      list: list,\n      path: relativePath,\n      pathAbsolute: absolutePath\n    };\n    this.resources[relativePath] = resource;\n    log(\"resourceManager.initPath() setting resource...\", {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path\n    });\n  }\n\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot): {} {\n    const data = doc.data();\n    parseAllDatesDoc(data);\n    // React Admin requires an id field on every document,\n    // So we can just using the firestore document id\n    return { id: doc.id, ...data };\n  }\n\n  public async getUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      this.fireWrapper.auth().onAuthStateChanged(user => {\n        resolve(user);\n      });\n    });\n  }\n\n  private removeResource(resourceName: string) {\n    delete this.resources[resourceName];\n  }\n\n  private applyQuery(\n    collection: CollectionReference,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): CollectionReference {\n    let collref: CollectionReference;\n    if (collectionQuery) {\n      collref = collectionQuery(collection);\n    } else {\n      collref = collection;\n    }\n    log(\"resourceManager.applyQuery() ...\", {\n      collection,\n      collectionQuery: (collectionQuery || \"-\").toString(),\n      collref\n    });\n    return collref;\n  }\n}\n","export function parseAllDatesDoc(obj: {}) {\n  const isObject = !!obj && typeof obj === 'object';\n  if (!isObject) {\n    return;\n  }\n  Object.keys(obj).map(key => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value);\n  });\n}\n\nexport function recusivelyCheckObjectValue(input: any) {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return input.map(value => recusivelyCheckObjectValue(value));\n  }\n  const isObject = typeof input === 'object';\n  if (isObject) {\n    Object.keys(input).map(key => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value);\n    });\n    return input;\n  }\n}","import { FirebaseFirestore } from \"@firebase/firestore-types\";\nimport { ResourceManager, IResource } from \"./ResourceManager\";\nimport { RAFirebaseOptions } from \"../RAFirebaseOptions\";\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\nimport { IFirebaseClient } from \"./IFirebaseClient\";\nimport {\n  filterArray,\n  joinPaths,\n  log,\n  logError,\n  messageTypes,\n  sortArray,\n  parseDocGetAllUploads,\n} from \"../../misc\";\nimport { set } from 'lodash'\n\nexport class FirebaseClient implements IFirebaseClient {\n  private db: FirebaseFirestore;\n  private rm: ResourceManager;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions\n  ) {\n    this.db = fireWrapper.db();\n    this.rm = new ResourceManager(this.fireWrapper, this.options);\n  }\n\n  public async apiGetList(\n    resourceName: string,\n    params: messageTypes.IParamsGetList\n  ): Promise<messageTypes.IResponseGetList> {\n    log(\"apiGetList\", { resourceName, params });\n\n    const filterSafe = params.filter || {};\n\n    const collectionQuery = filterSafe.collectionQuery;\n    delete filterSafe.collectionQuery;\n\n    const r = await this.tryGetResource(\n      resourceName,\n      \"REFRESH\",\n      collectionQuery\n    );\n    const data = r.list;\n    if (params.sort != null) {\n      const { field, order } = params.sort;\n      if (order === \"ASC\") {\n        sortArray(data, field, \"asc\");\n      } else {\n        sortArray(data, field, \"desc\");\n      }\n    }\n    let softDeleted = data;\n    if (this.options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\n      softDeleted = data.filter(doc => !doc['deleted'])\n    }\n    const filteredData = filterArray(softDeleted, filterSafe);\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n    const pageEnd = pageStart + params.pagination.perPage;\n    const dataPage = filteredData.slice(pageStart, pageEnd);\n    const total = filteredData.length;\n    return {\n      data: dataPage,\n      total\n    };\n  }\n  public async apiGetOne(\n    resourceName: string,\n    params: messageTypes.IParamsGetOne\n  ): Promise<messageTypes.IResponseGetOne> {\n    log(\"apiGetOne\", { resourceName, params });\n    try {\n      const data = await this.rm.GetSingleDoc(resourceName, params.id);\n      return { data: data };\n    } catch (error) {\n      throw new Error(\n        \"Error getting id: \" + params.id + \" from collection: \" + resourceName\n      );\n    }\n  }\n  public async apiCreate(\n    resourceName: string,\n    params: messageTypes.IParamsCreate\n  ): Promise<messageTypes.IResponseCreate> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiCreate\", { resourceName, resource: r, params });\n    const hasOverridenDocId = params.data && params.data.id;\n    log(\"apiCreate\", { hasOverridenDocId });\n    if (hasOverridenDocId) {\n      const overridenId = params.data.id;\n      const exists = (await r.collection.doc(overridenId).get()).exists;\n      if (exists) {\n        throw new Error(\n          `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n        );\n      }\n      const data = await this.parseDataAndUpload(r, overridenId, params.data);\n      if (!overridenId) {\n        throw new Error(\"id must be a valid string\");\n      }\n      const docObj = { ...data };\n      this.checkRemoveIdField(docObj);\n      await this.addCreatedByFields(docObj);\n      await this.addUpdatedByFields(docObj);\n      log(\"apiCreate\", { docObj });\n      await r.collection.doc(overridenId).set(docObj, { merge: false });\n      return {\n        data: {\n          ...data,\n          id: overridenId\n        }\n      };\n    }\n    const newId = this.db.collection(\"collections\").doc().id;\n    const data = await this.parseDataAndUpload(r, newId, params.data);\n    const docObj = { ...data };\n    this.checkRemoveIdField(docObj);\n    await this.addCreatedByFields(docObj);\n    await this.addUpdatedByFields(docObj);\n    await r.collection.doc(newId).set(docObj, { merge: false });\n    return {\n      data: {\n        ...data,\n        id: newId\n      }\n    };\n  }\n  public async apiUpdate(\n    resourceName: string,\n    params: messageTypes.IParamsUpdate\n  ): Promise<messageTypes.IResponseUpdate> {\n    const id = params.id;\n    delete params.data.id;\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiUpdate\", { resourceName, resource: r, params });\n    const data = await this.parseDataAndUpload(r, id, params.data);\n    const docObj = { ...data };\n    this.checkRemoveIdField(docObj);\n    await this.addUpdatedByFields(docObj);\n    r.collection\n      .doc(id)\n      .update(docObj)\n      .catch(error => {\n        logError(\"apiUpdate error\", { error });\n      });\n    return {\n      data: {\n        ...data,\n        id: id\n      }\n    };\n  }\n  public async apiUpdateMany(\n    resourceName: string,\n    params: messageTypes.IParamsUpdateMany\n  ): Promise<messageTypes.IResponseUpdateMany> {\n    delete params.data.id;\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiUpdateMany\", { resourceName, resource: r, params });\n    const ids = params.ids;\n    const returnData = await Promise.all(\n      ids.map(async id => {\n        const data = await this.parseDataAndUpload(r, id, params.data);\n        const docObj = { ...data };\n        this.checkRemoveIdField(docObj);\n        await this.addUpdatedByFields(docObj);\n        await r.collection\n          .doc(id)\n          .update(docObj)\n        return {\n          ...data,\n          id: id\n        };\n      })\n    );\n    return {\n      data: returnData\n    };\n  }\n  public async apiSoftDelete(\n    resourceName: string,\n    params: messageTypes.IParamsUpdate\n  ): Promise<messageTypes.IResponseUpdate> {\n    const id = params.id;\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiSoftDelete\", { resourceName, resource: r, params });\n    const docObj = { deleted: true };\n    await this.addUpdatedByFields(docObj);\n    r.collection\n      .doc(id)\n      .update(docObj)\n      .catch(error => {\n        logError(\"apiSoftDelete error\", { error });\n      });\n    return {\n      data: {\n        ...params.previousData,\n        id: id\n      },\n    };\n  }\n  public async apiSoftDeleteMany(\n    resourceName: string,\n    params: messageTypes.IParamsUpdateMany\n  ): Promise<messageTypes.IResponseUpdateMany> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiSoftDeleteMany\", { resourceName, resource: r, params });\n    const ids = params.ids;\n    const returnData = await Promise.all(\n      ids.map(async id => {\n        const docObj = { deleted: true };\n        await this.addUpdatedByFields(docObj);\n        r.collection\n          .doc(id)\n          .update(docObj)\n          .catch(error => {\n            logError(\"apiSoftDeleteMany error\", { error });\n          });\n        return {\n          ...params.data,\n          id: id\n        };\n      })\n    );\n    return {\n      data: returnData\n    };\n  }\n  public async apiDelete(\n    resourceName: string,\n    params: messageTypes.IParamsDelete\n  ): Promise<messageTypes.IResponseDelete> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiDelete\", { resourceName, resource: r, params });\n    try {\n      await r.collection\n        .doc(params.id)\n        .delete()\n    } catch (error) {\n      throw new Error(error)\n    }\n    return {\n      data: params.previousData\n    };\n  }\n  public async apiDeleteMany(\n    resourceName: string,\n    params: messageTypes.IParamsDeleteMany\n  ): Promise<messageTypes.IResponseDeleteMany> {\n    const r = await this.tryGetResource(resourceName);\n    log(\"apiDeleteMany\", { resourceName, resource: r, params });\n    const returnData: { id: string }[] = [];\n    const batch = this.db.batch();\n    for (const id of params.ids) {\n      batch.delete(r.collection.doc(id));\n      returnData.push({ id });\n    }\n    try {\n      await batch.commit();\n    } catch (error) {\n      throw new Error(error)\n    }\n    return { data: returnData };\n  }\n  public async apiGetMany(\n    resourceName: string,\n    params: messageTypes.IParamsGetMany\n  ): Promise<messageTypes.IResponseGetMany> {\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\n    log(\"apiGetMany\", { resourceName, resource: r, params });\n    const ids = params.ids;\n    const matchDocSnaps = await Promise.all(\n      ids.map(id => r.collection.doc(id).get())\n    );\n    const matches = matchDocSnaps.map(snap => {\n      return { ...snap.data(), id: snap.id };\n    });\n    const permittedData = this.options.softDelete ? matches.filter(row => !row['deleted']) : matches;\n    return {\n      data: permittedData\n    };\n  }\n  public async apiGetManyReference(\n    resourceName: string,\n    params: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName, \"REFRESH\");\n    log(\"apiGetManyReference\", { resourceName, resource: r, params });\n    const data = r.list;\n    const targetField = params.target;\n    const targetValue = params.id;\n    const filterSafe = params.filter || {};\n    let softDeleted = data;\n    if (this.options.softDelete) {\n      softDeleted = data.filter(doc => !doc['deleted'])\n    }\n    const filteredData = filterArray(softDeleted, filterSafe);\n    const targetIdFilter = {}\n    targetIdFilter[targetField] = targetValue;\n    const permittedData = filterArray(filteredData, targetIdFilter);\n    if (params.sort != null) {\n      const { field, order } = params.sort;\n      if (order === \"ASC\") {\n        sortArray(permittedData, field, \"asc\");\n      } else {\n        sortArray(permittedData, field, \"desc\");\n      }\n    }\n    const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n    const pageEnd = pageStart + params.pagination.perPage;\n    const dataPage = permittedData.slice(pageStart, pageEnd);\n    const total = permittedData.length;\n    return { data: dataPage, total };\n  }\n  private async tryGetResource(\n    resourceName: string,\n    refresh?: \"REFRESH\",\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.rm.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n  private async getCurrentUserEmail() {\n    const user = await this.rm.getUserLogin();\n    if (user) {\n      return user.email;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.rm.getUserLogin();\n    if (user) {\n      return user.uid;\n    } else {\n      return \"annonymous user\";\n    }\n  }\n\n  private async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = r.collection.doc(id).path;\n\n    const uploads = parseDocGetAllUploads(data);\n    await Promise.all(\n      uploads.map(async (u) => {\n        const link = await this.uploadAndGetLink(u.rawFile, docPath, u.fieldSlashesPath)\n        set(data, u.fieldDotsPath + '.src', link);\n      })\n    );\n    return data;\n  }\n\n  private checkRemoveIdField(obj: any) {\n    if (this.options.dontAddIdFieldToDoc) {\n      delete obj.id\n    }\n  }\n\n  private async addCreatedByFields(obj: any) {\n    if (this.options.disableMeta) {\n      return;\n    }\n    const currentUserIdentifier = this.options.associateUsersById ? await this.getCurrentUserId() : await this.getCurrentUserEmail();\n    switch (this.options.metaFieldCasing) {\n      case 'camel':\n        obj.createDate = this.fireWrapper.serverTimestamp();\n        obj.createdBy = currentUserIdentifier;\n        break;\n      case 'snake':\n        obj.create_date = this.fireWrapper.serverTimestamp();\n        obj.created_by = currentUserIdentifier;\n        break;\n      case 'pascal':\n        obj.CreateDate = this.fireWrapper.serverTimestamp();\n        obj.CreatedBy = currentUserIdentifier;\n        break;\n      case 'kebab':\n        obj['create-date'] = this.fireWrapper.serverTimestamp();\n        obj['created-by'] = currentUserIdentifier;\n        break;\n      default:\n        obj.createdate = this.fireWrapper.serverTimestamp();\n        obj.createdby = currentUserIdentifier;\n        break;\n    }\n  }\n\n  private async addUpdatedByFields(obj: any) {\n    if (this.options.disableMeta) {\n      return;\n    }\n    const currentUserIdentifier = this.options.associateUsersById ? await this.getCurrentUserId() : await this.getCurrentUserEmail();\n    switch (this.options.metaFieldCasing) {\n      case 'camel':\n        obj.lastUpdate = this.fireWrapper.serverTimestamp();\n        obj.updatedBy = currentUserIdentifier;\n        break;\n      case 'snake':\n        obj.last_update = this.fireWrapper.serverTimestamp();\n        obj.updated_by = currentUserIdentifier;\n        break;\n      case 'pascal':\n        obj.LastUpdate = this.fireWrapper.serverTimestamp();\n        obj.UpdatedBy = currentUserIdentifier;\n        break;\n      case 'kebab':\n        obj['last-update'] = this.fireWrapper.serverTimestamp();\n        obj['updated-by'] = currentUserIdentifier;\n        break;\n      default:\n        obj.lastupdate = this.fireWrapper.serverTimestamp();\n        obj.updatedby = currentUserIdentifier;\n        break;\n    }\n  }\n\n  private async uploadAndGetLink(\n    rawFile: any,\n    docPath: string,\n    fieldPath: string\n  ): Promise<string> {\n    const storagePath = joinPaths(docPath, fieldPath);\n    const storageLink = await this.saveFile(storagePath, rawFile);\n    return storageLink;\n  }\n\n  private async saveFile(storagePath: string, rawFile: any): Promise<string> {\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\n    const task = this.fireWrapper\n      .storage()\n      .ref(storagePath)\n      .put(rawFile);\n    try {\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\n        (res, rej) => task.then(res).catch(rej)\n      );\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\n      log(\"saveFile() saved file\", {\n        storagePath,\n        taskResult,\n        getDownloadURL\n      });\n      return getDownloadURL;\n    } catch (storageError) {\n      if (storageError.code === \"storage/unknown\") {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError(\"saveFile() error saving file\", {\n          storageError\n        });\n      }\n    }\n  }\n}\n","interface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\nexport function parseDocGetAllUploads(obj: {}): ParsedUpload[] {\n  const isObject = !!obj && typeof obj === \"object\";\n  if (!isObject) {\n    return [];\n  }\n  const uploads = [];\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, uploads);\n  });\n  return uploads;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  uploads: ParsedUpload[]\n) {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== \"object\";\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === \"function\";\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, uploads)\n    );\n  }\n  const isObject = typeof input === \"object\";\n  if (!isObject) {\n    return;\n  }\n  const isFileField = !!input && input.hasOwnProperty(\"rawFile\");\n  if (isFileField) {\n    uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split('.').join('/'),\n      rawFile: input.rawFile,\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, uploads);\n  });\n  return input;\n}\n","import { logError } from \"./../misc/logger\";\nimport {\n  CREATE,\n  DELETE,\n  DELETE_MANY,\n  GET_LIST,\n  GET_MANY,\n  GET_MANY_REFERENCE,\n  GET_ONE,\n  UPDATE,\n  UPDATE_MANY,\n} from \"react-admin\";\nimport {\n  getAbsolutePath,\n  log,\n  CheckLogging,\n  messageTypes,\n  retrieveStatusCode,\n} from \"../misc\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseClient } from \"./database/FirebaseClient\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\n\nexport let fb: FirebaseClient;\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n) {\n  const options = optionsInput || {};\n  VerifyDataProviderArgs(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  log(\"react-admin-firebase:: Creating FirebaseDataProvider\", {\n    firebaseConfig,\n    options,\n  });\n  const fireWrapper = new FirebaseWrapper();\n  fireWrapper.init(firebaseConfig, optionsInput);\n  fb = new FirebaseClient(fireWrapper, options);\n  async function providerApi(\n    type: string,\n    resourceName: string,\n    params: any\n  ): Promise<messageTypes.IResponseAny> {\n    log(\"FirebaseDataProvider: event\", { type, resourceName, params });\n    let res: messageTypes.IResponseAny;\n    try {\n      switch (type) {\n        case GET_MANY:\n          res = await fb.apiGetMany(resourceName, params);\n          break;\n        case GET_MANY_REFERENCE:\n          res = await fb.apiGetManyReference(resourceName, params);\n          break;\n        case GET_LIST:\n          res = await fb.apiGetList(resourceName, params);\n          break;\n        case GET_ONE:\n          res = await fb.apiGetOne(resourceName, params);\n          break;\n        case CREATE:\n          res = await fb.apiCreate(resourceName, params);\n          break;\n        case UPDATE:\n          res = await fb.apiUpdate(resourceName, params);\n          break;\n        case UPDATE_MANY:\n          res = await fb.apiUpdateMany(resourceName, params);\n          break;\n        case DELETE:\n          if (options.softDelete)\n            res = await fb.apiSoftDelete(resourceName, params);\n          else res = await fb.apiDelete(resourceName, params);\n          break;\n        case DELETE_MANY:\n          if (options.softDelete)\n            res = await fb.apiSoftDeleteMany(resourceName, params);\n          else res = await fb.apiDeleteMany(resourceName, params);\n          break;\n        default:\n          throw new Error(`Unknkown dataprovider command type: \"${type}\"`);\n      }\n      return res;\n    } catch (error) {\n      const errorMsg = error.toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError('DataProvider:', error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  return providerApi;\n}\n\nfunction VerifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n  if (options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, \"test\");\n  }\n}\n","import { IFirebaseWrapper } from \"./IFirebaseWrapper\";\nimport { RAFirebaseOptions } from \"providers/RAFirebaseOptions\";\n\nimport firebase from \"firebase/app\";\nimport \"firebase/firestore\";\nimport \"firebase/auth\";\nimport \"firebase/storage\";\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private firestore: firebase.firestore.Firestore;\n  private app: firebase.app.App;\n\n  constructor() { }\n  public options: RAFirebaseOptions;\n\n  public init(firebaseConfig: {}, options: RAFirebaseOptions): void {\n    this.options = options;\n    this.app = ObtainFirebaseApp(firebaseConfig, options);\n    this.firestore = this.app.firestore();\n  }\n  public db(): firebase.firestore.Firestore {\n    return this.firestore;\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    // return firebase.firestore.FieldValue.serverTimestamp();\n    return new Date();\n  }\n  public auth() {\n    return this.app.auth() as any;\n  }\n  public storage() {\n    return this.app.storage();\n  }\n}\n\nfunction ObtainFirebaseApp(firebaseConfig: {}, options: RAFirebaseOptions): firebase.app.App {\n  if (options.app) {\n    return options.app;\n  }\n  const isInitialized = !!firebase.apps.length;\n  if (isInitialized) {\n    const app = firebase.app();\n    return app;\n  } else {\n    const app = firebase.initializeApp(firebaseConfig);\n    return app;\n  }\n}","import { messageTypes } from './../misc/messageTypes';\nimport firebase from \"firebase/app\";\nimport \"firebase/auth\";\nimport { FirebaseAuth } from \"@firebase/auth-types\";\nimport { log, CheckLogging, retrieveStatusTxt } from \"../misc\";\nimport { RAFirebaseOptions } from \"./RAFirebaseOptions\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\n\nclass AuthClient {\n  private auth: FirebaseAuth;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log(\"Auth Client: initializing...\", { firebaseConfig, options });\n    const fireWrapper = new FirebaseWrapper();\n    fireWrapper.init(firebaseConfig, options);\n    this.auth = fireWrapper.auth();\n    this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: \"session\" | \"local\" | \"none\") {\n    let persistenceResolved: string;\n    switch (persistenceInput) {\n      case \"local\":\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\n        break;\n      case \"none\":\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\n        break;\n      case \"session\":\n      default:\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\n        break;\n    }\n    log(\"setPersistence\", { persistenceInput, persistenceResolved });\n    this.auth\n      .setPersistence(persistenceResolved)\n      .catch(error => console.error(error));\n  }\n\n  public async HandleAuthLogin(params) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.auth.signInWithEmailAndPassword(\n          username,\n          password\n        );\n        log(\"HandleAuthLogin: user sucessfully logged in\", { user });\n        return user;\n      } catch (e) {\n        log(\"HandleAuthLogin: invalid credentials\", { params });\n        throw new Error(\"Login error: invalid credentials\");\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.auth.signOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log(\"HandleAuthLogin: invalid credentials\", { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === 'ok') {\n      return Promise.resolve(\"API is authenticated\");\n    }\n    return Promise.reject(\"Recieved authentication error from API\");\n  }\n\n\n\n  public HandleAuthCheck() {\n    return this.getUserLogin();\n  }\n\n  public getUserLogin() {\n    return new Promise((resolve, reject) => {\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\n      const unsubscribe = this.auth.onAuthStateChanged(user => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log(\"HandleGetPermission: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log(\"HandleGetJWTAuthTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\"HandleGetJWTExpirationTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n    public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\"HandleGetJWTSignInProvider: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n     public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n\n      public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log(\"HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error\", {\n        e\n      });\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(firebaseConfig: {}, options: RAFirebaseOptions) {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  const auth = new AuthClient(firebaseConfig, options);\n  CheckLogging(firebaseConfig, options);\n\n  return {\n    login: params => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: error => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken()\n  };\n}\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      \"Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider\"\n    );\n  }\n}\n","// From firebase SDK\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): \"ok\" | \"unauthenticated\" {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return \"ok\";\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return \"unauthenticated\";\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return \"ok\";\n  }\n}\n\n// From firebase SDK\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const status = /\\[code\\=([\\w-]*)/g.exec(statusTxt)[1];\n  switch (status) {\n    case 'unauthenticated':\n      return 401\n    case 'permission-denied':\n      return 403\n    case 'internal':\n      return 0\n    case 'invalid-argument':\n      return 400\n    case 'not-found':\n      return 404\n    case 'aborted':\n      return 409\n    case 'resource-exhausted':\n      return 429\n    case 'cancelled':\n      return 499\n    case 'internal':\n      return 500\n    case 'unimplemented':\n      return 501\n    case 'unavailable':\n      return 503\n    case 'deadline-exceeded':\n      return 504\n    default:\n      return 200;\n  }\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_catch","body","recover","Symbol","iterator","asyncIterator","SimpleLogger","constructor","isEnabled","localStorage","getItem","log","console","title","warn","error","const","logger","CheckLogging","config","options","logging","setItem","removeItem","logError","sortArray","data","field","dir","sort","a","b","rawA","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","Object","keys","map","fieldName","getSubObjects","searchField","searchValue","tree","leaves","recursivelyWalk","obj","path","key","hasOwnProperty","objVal","currentPath","Array","push","objectFlatten","getFieldReferences","filter","row","reduce","prev","curr","searchThis","includes","get","toString","doesRowMatch","getAbsolutePath","rootRef","relativePath","Error","withSlashes","join","split","length","slice","ResourceManager","fireWrapper","db","GetResource","resource","resources","TryGetResourcePromise","collectionQuery","initPath","RefreshResource","_this2","collection","query","applyQuery","newDocs","list","docs","doc","parseFireStoreDocument","collectionPath","GetSingleDoc","docId","_this3","docSnap","exists","absolutePath","hasBeenInited","pathAbsolute","allResources","recusivelyCheckObjectValue","input","toDate","isArray","id","getUserLogin","Promise","resolve","reject","auth","onAuthStateChanged","user","removeResource","resourceName","collref","FirebaseClient","rm","apiGetList","params","filterSafe","tryGetResource","r","softDeleted","softDelete","filteredData","pageStart","pagination","page","perPage","apiGetOne","apiCreate","newId","parseDataAndUpload","docObj","checkRemoveIdField","addCreatedByFields","addUpdatedByFields","set","merge","hasOverridenDocId","overridenId","_r$collection$doc$get","apiUpdate","_this4","update","catch","apiUpdateMany","_this5","all","ids","returnData","apiSoftDelete","_this6","deleted","previousData","apiSoftDeleteMany","_this7","apiDelete","delete","apiDeleteMany","_this9","batch","commit","apiGetMany","_this10","matchDocSnaps","matches","snap","apiGetManyReference","_this11","targetField","target","targetValue","targetIdFilter","permittedData","refresh","_this12","getCurrentUserEmail","email","getCurrentUserId","uid","docPath","uploads","recusivelyParseObjectValue","fieldPath","index","fieldDotsPath","fieldSlashesPath","rawFile","parseDocGetAllUploads","u","_this15","uploadAndGetLink","link","dontAddIdFieldToDoc","_this16","disableMeta","associateUsersById","currentUserIdentifier","metaFieldCasing","createDate","serverTimestamp","createdBy","create_date","created_by","CreateDate","CreatedBy","createdate","createdby","_this17","lastUpdate","updatedBy","last_update","updated_by","LastUpdate","UpdatedBy","lastupdate","updatedby","storagePath","saveFile","task","storage","ref","put","res","rej","taskResult","getDownloadURL","storageError","code","fb","FirebaseWrapper","init","firebaseConfig","app","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","AuthClient","optionsInput","setPersistence","persistence","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","HandleAuthLogin","username","password","signInWithEmailAndPassword","HandleAuthLogout","signOut","HandleAuthError","errorHttp","status","retrieveStatusTxt","HandleAuthCheck","currentUser","unsubscribe","HandleGetPermissions","getIdTokenResult","token","claims","HandleGetJWTAuthTime","authTime","HandleGetJWTExpirationTime","expirationTime","HandleGetJWTSignInProvider","signInProvider","HandleGetJWTIssuedAtTime","issuedAtTime","HandleGetJWTToken","VerifyDataProviderArgs","type","discriminant","cases","awaitBody","dispatchIndex","outer","i","test","testValue","fallthroughCheck","_resumeAfterBody","_resumeAfterTest","GET_MANY","GET_MANY_REFERENCE","GET_LIST","GET_ONE","CREATE","UPDATE","UPDATE_MANY","DELETE","DELETE_MANY","errorMsg","statusTxt","exec","retrieveStatusCode","errorObj","message","json","VerifyAuthProviderArgs","login","logout","checkAuth","checkError","getPermissions","getJWTAuthTime","getJWTExpirationTime","getJWTSignInProvider","getJWTClaims","getJWTToken"],"mappings":"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"}