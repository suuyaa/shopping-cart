{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst google_gax_1 = require(\"google-gax\");\n/*!\n * Google Cloud Functions terminates idle connections after two minutes. After\n * longer periods of idleness, we issue transactional commits to allow for\n * retries.\n */\n\n\nconst GCF_IDLE_TIMEOUT_MS = 110 * 1000;\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\n\nclass WriteResult {\n  /**\n   * @hideconstructor\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  constructor(_writeTime) {\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n   * });\n   */\n\n\n  get writeTime() {\n    return this._writeTime;\n  }\n  /**\n   * Returns true if this `WriteResult` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return true if this `WriteResult` is equal to the provided value.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n  }\n\n}\n\nexports.WriteResult = WriteResult;\n/**\n * A BatchWriteResult wraps the write time and status returned by Firestore\n * when making BatchWriteRequests.\n *\n * @private\n */\n\nclass BatchWriteResult {\n  constructor(writeTime, status) {\n    this.writeTime = writeTime;\n    this.status = status;\n  }\n\n}\n\nexports.BatchWriteResult = BatchWriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\n\nclass WriteBatch {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore) {\n    /**\n     * An array of write operations that are executed as part of the commit. The\n     * resulting `api.IWrite` will be sent to the backend.\n     * @private\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n    this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * Checks if this write batch has any pending operations.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this._ops.length === 0;\n  }\n  /**\n   * Throws an error if this batch has already been committed.\n   *\n   * @private\n   */\n\n\n  verifyNotCommitted() {\n    if (this._committed) {\n      throw new Error('Cannot modify a WriteBatch that has been committed.');\n    }\n  }\n  /**\n   * Create a document with the provided object values. This will fail the batch\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * writeBatch.create(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  create(documentRef, data) {\n    reference_1.validateDocumentReference('documentRef', documentRef);\n\n    const firestoreData = documentRef._converter.toFirestore(data);\n\n    validateDocumentData('data', firestoreData,\n    /* allowDeletes= */\n    false, this._allowUndefined);\n    this.verifyNotCommitted();\n    const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n    transform.validate();\n    const precondition = new document_1.Precondition({\n      exists: false\n    });\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n      const write = document.toProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      return {\n        write,\n        precondition: precondition.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Deletes a document from the database.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the batch if the\n   * document doesn't exist or was last updated at a different time.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.delete(documentRef);\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  delete(documentRef, precondition) {\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    validateDeletePrecondition('precondition', precondition, {\n      optional: true\n    });\n    this.verifyNotCommitted();\n    const conditions = new document_1.Precondition(precondition);\n\n    const op = () => {\n      return {\n        write: {\n          delete: documentRef.formattedName\n        },\n        precondition: conditions.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Write to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}.\n   * If the document does not exist yet, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}., the provided data can be merged\n   * into the existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {T} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call\n   * remain untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  set(documentRef, data, options) {\n    validateSetOptions('options', options, {\n      optional: true\n    });\n    const mergeLeaves = options && options.merge === true;\n    const mergePaths = options && options.mergeFields;\n    reference_1.validateDocumentReference('documentRef', documentRef);\n\n    let firestoreData = documentRef._converter.toFirestore(data);\n\n    validateDocumentData('data', firestoreData,\n    /* allowDeletes= */\n    !!(mergePaths || mergeLeaves), this._allowUndefined);\n    this.verifyNotCommitted();\n    let documentMask;\n\n    if (mergePaths) {\n      documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n      firestoreData = documentMask.applyTo(firestoreData);\n    }\n\n    const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n    transform.validate();\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n\n      if (mergePaths) {\n        documentMask.removeFields(transform.fields);\n      } else if (mergeLeaves) {\n        documentMask = document_1.DocumentMask.fromObject(firestoreData);\n      }\n\n      const write = document.toProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      if (mergePaths || mergeLeaves) {\n        write.updateMask = documentMask.toProto();\n      }\n\n      return {\n        write\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Update fields of the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document\n   * doesn't yet exist, the update fails and the entire batch will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object\n   * containing the fields and values with which to update the document\n   * or the path of the first field to update.\n   * @param {\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n   * An alternating list of field paths and values to update or a Precondition\n   * to restrict this update.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.update(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n    reference_1.validateDocumentReference('documentRef', documentRef);\n    this.verifyNotCommitted();\n    const updateMap = new Map();\n    let precondition = new document_1.Precondition({\n      exists: true\n    });\n    const argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n    const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n    if (usesVarargs) {\n      try {\n        for (let i = 1; i < arguments.length; i += 2) {\n          if (i === arguments.length - 1) {\n            validateUpdatePrecondition(i, arguments[i]);\n            precondition = new document_1.Precondition(arguments[i]);\n          } else {\n            path_1.validateFieldPath(i, arguments[i]); // Unlike the `validateMinNumberOfArguments` invocation above, this\n            // validation can be triggered both from `WriteBatch.update()` and\n            // `DocumentReference.update()`. Hence, we don't use the fully\n            // qualified API name in the error message.\n\n            validate_1.validateMinNumberOfArguments('update', arguments, i + 1);\n            const fieldPath = path_1.FieldPath.fromArgument(arguments[i]);\n            validateFieldValue(i, arguments[i + 1], this._allowUndefined, fieldPath);\n            updateMap.set(fieldPath, arguments[i + 1]);\n          }\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n        // error message.\n\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    } else {\n      try {\n        validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n        validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n        const data = dataOrField;\n        Object.keys(data).forEach(key => {\n          path_1.validateFieldPath(key, key);\n          updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n        });\n\n        if (preconditionOrValues.length > 0) {\n          validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n          precondition = new document_1.Precondition(preconditionOrValues[0]);\n        }\n      } catch (err) {\n        logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n        // message to describe the usage of update() better.\n\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    }\n\n    validateNoConflictingFields('dataOrField', updateMap);\n    const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n    transform.validate();\n    const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n      const write = document.toProto();\n      write.updateMask = documentMask.toProto();\n\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n\n      return {\n        write,\n        precondition: precondition.toProto()\n      };\n    };\n\n    this._ops.push(op);\n\n    return this;\n  }\n  /**\n   * Atomically commits all pending operations to the database and verifies all\n   * preconditions. Fails the entire write if any precondition is not met.\n   *\n   * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n   * when this batch completes.\n   *\n   * @example\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   */\n\n\n  commit() {\n    return this.commit_();\n  }\n  /**\n   * Commits all pending operations to the database and verifies all\n   * preconditions.\n   *\n   * The writes in the batch are not applied atomically and can be applied out\n   * of order.\n   *\n   * @private\n   */\n\n\n  async bulkCommit() {\n    this._committed = true;\n    const tag = util_1.requestTag();\n    await this._firestore.initializeIfNeeded(tag);\n    const database = this._firestore.formattedName;\n    const request = {\n      database,\n      writes: []\n    };\n\n    const writes = this._ops.map(op => op());\n\n    for (const req of writes) {\n      if (req.precondition) {\n        req.write.currentDocument = req.precondition;\n      }\n\n      request.writes.push(req.write);\n    }\n\n    const response = await this._firestore.request('batchWrite', request, tag);\n    return (response.writeResults || []).map((result, i) => {\n      const status = response.status[i];\n      const error = new google_gax_1.GoogleError(status.message || undefined);\n      error.code = status.code;\n      return new BatchWriteResult(result.updateTime ? timestamp_1.Timestamp.fromProto(result.updateTime) : null, error);\n    });\n  }\n  /**\n   * Commit method that takes an optional transaction ID.\n   *\n   * @private\n   * @param commitOptions Options to use for this commit.\n   * @param commitOptions.transactionId The transaction ID of this commit.\n   * @param commitOptions.requestTag A unique client-assigned identifier for\n   * this request.\n   * @returns  A Promise that resolves when this batch completes.\n   */\n\n\n  async commit_(commitOptions) {\n    // Note: We don't call `verifyNotCommitted()` to allow for retries.\n    this._committed = true;\n    const tag = commitOptions && commitOptions.requestTag || util_1.requestTag();\n    await this._firestore.initializeIfNeeded(tag);\n    const database = this._firestore.formattedName; // On GCF, we periodically force transactional commits to allow for\n    // request retries in case GCF closes our backend connection.\n\n    const explicitTransaction = commitOptions && commitOptions.transactionId;\n\n    if (!explicitTransaction && this._shouldCreateTransaction()) {\n      logger_1.logger('WriteBatch.commit', tag, 'Using transaction for commit');\n      return this._firestore.request('beginTransaction', {\n        database\n      }, tag).then(resp => {\n        return this.commit_({\n          transactionId: resp.transaction\n        });\n      });\n    }\n\n    const request = {\n      database,\n      writes: []\n    };\n\n    const writes = this._ops.map(op => op());\n\n    for (const req of writes) {\n      if (req.precondition) {\n        req.write.currentDocument = req.precondition;\n      }\n\n      request.writes.push(req.write);\n    }\n\n    logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n\n    if (explicitTransaction) {\n      request.transaction = explicitTransaction;\n    }\n\n    const response = await this._firestore.request('commit', request, tag);\n    return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n  }\n  /**\n   * Determines whether we should issue a transactional commit. On GCF, this\n   * happens after two minutes of idleness.\n   *\n   * @private\n   * @returns Whether to use a transaction.\n   */\n\n\n  _shouldCreateTransaction() {\n    if (!this._firestore._preferTransactions) {\n      return false;\n    }\n\n    if (this._firestore._lastSuccessfulRequest) {\n      const now = new Date().getTime();\n      return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;\n    }\n\n    return true;\n  }\n  /**\n   * Resets the WriteBatch and dequeues all pending operations.\n   * @private\n   */\n\n\n  _reset() {\n    this._ops.splice(0);\n\n    this._committed = false;\n  }\n\n}\n\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\n\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n\n  const precondition = value;\n  let conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExists) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n    }\n\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\n  }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    false);\n  }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\n\n\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    validatePrecondition(arg, value,\n    /* allowExists= */\n    true);\n  }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\n\n\nfunction validateSetOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\n    }\n\n    const setOptions = value;\n\n    if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\n    }\n\n    if ('mergeFields' in setOptions) {\n      if (!Array.isArray(setOptions.mergeFields)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\n      }\n\n      for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n        }\n      }\n    }\n\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n    }\n  }\n}\n\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n    allowDeletes: allowDeletes ? 'all' : 'none',\n    allowTransforms: true,\n    allowUndefined\n  });\n}\n\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\n\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n  serializer_1.validateUserInput(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true,\n    allowUndefined\n  }, path);\n}\n\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\n\nfunction validateNoConflictingFields(arg, data) {\n  const fields = [];\n  data.forEach((value, key) => {\n    fields.push(key);\n  });\n  fields.sort((left, right) => left.compareTo(right));\n\n  for (let i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n    }\n  }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\n\n\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n  if (!util_1.isPlainObject(obj)) {\n    throw new Error(validate_1.customObjectMessage(arg, obj));\n  }\n\n  let isEmpty = true;\n\n  if (obj) {\n    for (const prop of Object.keys(obj)) {\n      isEmpty = false;\n      validateFieldValue(arg, obj[prop], allowUndefined, new path_1.FieldPath(prop));\n    }\n  }\n\n  if (isEmpty) {\n    throw new Error('At least one field must be updated.');\n  }\n}","map":{"version":3,"sources":["/Users/suya/Desktop/front end study/webProjects/shopping-cart/node_modules/@google-cloud/firestore/build/src/write-batch.js"],"names":["Object","defineProperty","exports","value","document_1","require","logger_1","path_1","reference_1","serializer_1","timestamp_1","util_1","validate_1","google_gax_1","GCF_IDLE_TIMEOUT_MS","WriteResult","constructor","_writeTime","writeTime","isEqual","other","BatchWriteResult","status","WriteBatch","firestore","_ops","_committed","_firestore","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","isEmpty","length","verifyNotCommitted","Error","create","documentRef","data","validateDocumentReference","firestoreData","_converter","toFirestore","validateDocumentData","transform","DocumentTransform","fromObject","validate","precondition","Precondition","exists","op","document","DocumentSnapshot","write","toProto","updateTransforms","push","delete","validateDeletePrecondition","optional","conditions","formattedName","set","options","validateSetOptions","mergeLeaves","merge","mergePaths","mergeFields","documentMask","DocumentMask","fromFieldMask","applyTo","removeFields","fields","updateMask","update","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","updateMap","Map","argumentError","usesVarargs","FieldPath","i","validateUpdatePrecondition","validateFieldPath","fieldPath","fromArgument","validateFieldValue","err","logger","message","validateUpdateMap","validateMaxNumberOfArguments","keys","forEach","key","validateNoConflictingFields","fromUpdateMap","commit","commit_","bulkCommit","tag","requestTag","initializeIfNeeded","database","request","writes","map","req","currentDocument","response","writeResults","result","error","GoogleError","undefined","code","updateTime","Timestamp","fromProto","commitOptions","explicitTransaction","transactionId","_shouldCreateTransaction","then","resp","transaction","writeResult","commitTime","_preferTransactions","_lastSuccessfulRequest","now","Date","getTime","_reset","splice","validatePrecondition","arg","allowExists","invalidArgumentMessage","lastUpdateTime","validateOptional","isObject","setOptions","Array","isArray","obj","allowDeletes","allowUndefined","isPlainObject","customObjectMessage","validateUserInput","allowTransforms","val","path","sort","left","right","compareTo","isPrefixOf","prop"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst document_1 = require(\"./document\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst google_gax_1 = require(\"google-gax\");\n/*!\n * Google Cloud Functions terminates idle connections after two minutes. After\n * longer periods of idleness, we issue transactional commits to allow for\n * retries.\n */\nconst GCF_IDLE_TIMEOUT_MS = 110 * 1000;\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\nclass WriteResult {\n    /**\n     * @hideconstructor\n     *\n     * @param _writeTime The time of the corresponding document write.\n     */\n    constructor(_writeTime) {\n        this._writeTime = _writeTime;\n    }\n    /**\n     * The write time as set by the Firestore servers.\n     *\n     * @type {Timestamp}\n     * @name WriteResult#writeTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(writeResult => {\n     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n     * });\n     */\n    get writeTime() {\n        return this._writeTime;\n    }\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof WriteResult &&\n                this._writeTime.isEqual(other._writeTime)));\n    }\n}\nexports.WriteResult = WriteResult;\n/**\n * A BatchWriteResult wraps the write time and status returned by Firestore\n * when making BatchWriteRequests.\n *\n * @private\n */\nclass BatchWriteResult {\n    constructor(writeTime, status) {\n        this.writeTime = writeTime;\n        this.status = status;\n    }\n}\nexports.BatchWriteResult = BatchWriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\nclass WriteBatch {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore) {\n        /**\n         * An array of write operations that are executed as part of the commit. The\n         * resulting `api.IWrite` will be sent to the backend.\n         * @private\n         */\n        this._ops = [];\n        this._committed = false;\n        this._firestore = firestore;\n        this._serializer = new serializer_1.Serializer(firestore);\n        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * Checks if this write batch has any pending operations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._ops.length === 0;\n    }\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     */\n    verifyNotCommitted() {\n        if (this._committed) {\n            throw new Error('Cannot modify a WriteBatch that has been committed.');\n        }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    create(documentRef, data) {\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        const firestoreData = documentRef._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ false, this._allowUndefined);\n        this.verifyNotCommitted();\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const precondition = new document_1.Precondition({ exists: false });\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            const write = document.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            return {\n                write,\n                precondition: precondition.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    delete(documentRef, precondition) {\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        validateDeletePrecondition('precondition', precondition, { optional: true });\n        this.verifyNotCommitted();\n        const conditions = new document_1.Precondition(precondition);\n        const op = () => {\n            return {\n                write: {\n                    delete: documentRef.formattedName,\n                },\n                precondition: conditions.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}.\n     * If the document does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}., the provided data can be merged\n     * into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    set(documentRef, data, options) {\n        validateSetOptions('options', options, { optional: true });\n        const mergeLeaves = options && options.merge === true;\n        const mergePaths = options && options.mergeFields;\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        let firestoreData = documentRef._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);\n        this.verifyNotCommitted();\n        let documentMask;\n        if (mergePaths) {\n            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n            firestoreData = documentMask.applyTo(firestoreData);\n        }\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            if (mergePaths) {\n                documentMask.removeFields(transform.fields);\n            }\n            else if (mergeLeaves) {\n                documentMask = document_1.DocumentMask.fromObject(firestoreData);\n            }\n            const write = document.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            if (mergePaths || mergeLeaves) {\n                write.updateMask = documentMask.toProto();\n            }\n            return {\n                write,\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        this.verifyNotCommitted();\n        const updateMap = new Map();\n        let precondition = new document_1.Precondition({ exists: true });\n        const argumentError = 'Update() requires either a single JavaScript ' +\n            'object or an alternating list of field/value pairs that can be ' +\n            'followed by an optional precondition.';\n        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n        if (usesVarargs) {\n            try {\n                for (let i = 1; i < arguments.length; i += 2) {\n                    if (i === arguments.length - 1) {\n                        validateUpdatePrecondition(i, arguments[i]);\n                        precondition = new document_1.Precondition(arguments[i]);\n                    }\n                    else {\n                        path_1.validateFieldPath(i, arguments[i]);\n                        // Unlike the `validateMinNumberOfArguments` invocation above, this\n                        // validation can be triggered both from `WriteBatch.update()` and\n                        // `DocumentReference.update()`. Hence, we don't use the fully\n                        // qualified API name in the error message.\n                        validate_1.validateMinNumberOfArguments('update', arguments, i + 1);\n                        const fieldPath = path_1.FieldPath.fromArgument(arguments[i]);\n                        validateFieldValue(i, arguments[i + 1], this._allowUndefined, fieldPath);\n                        updateMap.set(fieldPath, arguments[i + 1]);\n                    }\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err);\n                // We catch the validation error here and re-throw to provide a better\n                // error message.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        else {\n            try {\n                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n                validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n                const data = dataOrField;\n                Object.keys(data).forEach(key => {\n                    path_1.validateFieldPath(key, key);\n                    updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n                });\n                if (preconditionOrValues.length > 0) {\n                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n                    precondition = new document_1.Precondition(preconditionOrValues[0]);\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err);\n                // We catch the validation error here and prefix the error with a custom\n                // message to describe the usage of update() better.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        validateNoConflictingFields('dataOrField', updateMap);\n        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n        transform.validate();\n        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n            const write = document.toProto();\n            write.updateMask = documentMask.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            return {\n                write,\n                precondition: precondition.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    commit() {\n        return this.commit_();\n    }\n    /**\n     * Commits all pending operations to the database and verifies all\n     * preconditions.\n     *\n     * The writes in the batch are not applied atomically and can be applied out\n     * of order.\n     *\n     * @private\n     */\n    async bulkCommit() {\n        this._committed = true;\n        const tag = util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        const request = { database, writes: [] };\n        const writes = this._ops.map(op => op());\n        for (const req of writes) {\n            if (req.precondition) {\n                req.write.currentDocument = req.precondition;\n            }\n            request.writes.push(req.write);\n        }\n        const response = await this._firestore.request('batchWrite', request, tag);\n        return (response.writeResults || []).map((result, i) => {\n            const status = response.status[i];\n            const error = new google_gax_1.GoogleError(status.message || undefined);\n            error.code = status.code;\n            return new BatchWriteResult(result.updateTime ? timestamp_1.Timestamp.fromProto(result.updateTime) : null, error);\n        });\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n    async commit_(commitOptions) {\n        // Note: We don't call `verifyNotCommitted()` to allow for retries.\n        this._committed = true;\n        const tag = (commitOptions && commitOptions.requestTag) || util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        // On GCF, we periodically force transactional commits to allow for\n        // request retries in case GCF closes our backend connection.\n        const explicitTransaction = commitOptions && commitOptions.transactionId;\n        if (!explicitTransaction && this._shouldCreateTransaction()) {\n            logger_1.logger('WriteBatch.commit', tag, 'Using transaction for commit');\n            return this._firestore\n                .request('beginTransaction', { database }, tag)\n                .then(resp => {\n                return this.commit_({ transactionId: resp.transaction });\n            });\n        }\n        const request = { database, writes: [] };\n        const writes = this._ops.map(op => op());\n        for (const req of writes) {\n            if (req.precondition) {\n                req.write.currentDocument = req.precondition;\n            }\n            request.writes.push(req.write);\n        }\n        logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n        if (explicitTransaction) {\n            request.transaction = explicitTransaction;\n        }\n        const response = await this._firestore.request('commit', request, tag);\n        return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n    }\n    /**\n     * Determines whether we should issue a transactional commit. On GCF, this\n     * happens after two minutes of idleness.\n     *\n     * @private\n     * @returns Whether to use a transaction.\n     */\n    _shouldCreateTransaction() {\n        if (!this._firestore._preferTransactions) {\n            return false;\n        }\n        if (this._firestore._lastSuccessfulRequest) {\n            const now = new Date().getTime();\n            return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;\n        }\n        return true;\n    }\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     */\n    _reset() {\n        this._ops.splice(0);\n        this._committed = false;\n    }\n}\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\nfunction validatePrecondition(arg, value, allowExists) {\n    if (typeof value !== 'object' || value === null) {\n        throw new Error('Input is not an object.');\n    }\n    const precondition = value;\n    let conditions = 0;\n    if (precondition.exists !== undefined) {\n        ++conditions;\n        if (!allowExists) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n        }\n        if (typeof precondition.exists !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\n        }\n    }\n    if (precondition.lastUpdateTime !== undefined) {\n        ++conditions;\n        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n        }\n    }\n    if (conditions > 1) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\n    }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateUpdatePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ false);\n    }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateDeletePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ true);\n    }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\nfunction validateSetOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\n        }\n        const setOptions = value;\n        if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\n        }\n        if ('mergeFields' in setOptions) {\n            if (!Array.isArray(setOptions.mergeFields)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\n            }\n            for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n                }\n            }\n        }\n        if ('merge' in setOptions && 'mergeFields' in setOptions) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n        }\n    }\n}\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n        allowDeletes: allowDeletes ? 'all' : 'none',\n        allowTransforms: true,\n        allowUndefined,\n    });\n}\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n    serializer_1.validateUserInput(arg, val, 'Firestore value', { allowDeletes: 'root', allowTransforms: true, allowUndefined }, path);\n}\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\nfunction validateNoConflictingFields(arg, data) {\n    const fields = [];\n    data.forEach((value, key) => {\n        fields.push(key);\n    });\n    fields.sort((left, right) => left.compareTo(right));\n    for (let i = 1; i < fields.length; ++i) {\n        if (fields[i - 1].isPrefixOf(fields[i])) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n        }\n    }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    let isEmpty = true;\n    if (obj) {\n        for (const prop of Object.keys(obj)) {\n            isEmpty = false;\n            validateFieldValue(arg, obj[prop], allowUndefined, new path_1.FieldPath(prop));\n        }\n    }\n    if (isEmpty) {\n        throw new Error('At least one field must be updated.');\n    }\n}\n//# sourceMappingURL=write-batch.js.map"]},"metadata":{},"sourceType":"script"}