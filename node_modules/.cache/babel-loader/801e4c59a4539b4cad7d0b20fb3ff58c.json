{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst assert = require(\"assert\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst rate_limiter_1 = require(\"./rate-limiter\");\n\nconst util_1 = require(\"./util\");\n\nconst write_batch_1 = require(\"./write-batch\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nconst MAX_BATCH_SIZE = 500;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nconst STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\n\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\n\nvar BatchState;\n\n(function (BatchState) {\n  BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n  BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n  BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nclass BulkCommitBatch {\n  constructor(writeBatch, maxBatchSize) {\n    this.writeBatch = writeBatch;\n    this.maxBatchSize = maxBatchSize;\n    /**\n     * The state of the batch.\n     */\n\n    this.state = BatchState.OPEN; // The set of document reference paths present in the WriteBatch.\n\n    this.docPaths = new Set(); // A deferred promise that is resolved after the batch has been sent, and a\n    // response is received.\n\n    this.completedDeferred = new util_1.Deferred(); // A map from each WriteBatch operation to its corresponding result.\n\n    this.resultsMap = new Map();\n  }\n  /**\n   * The number of writes in this batch.\n   */\n\n\n  get opCount() {\n    return this.resultsMap.size;\n  }\n  /**\n   * Adds a `create` operation to the WriteBatch. Returns a promise that\n   * resolves with the result of the write.\n   */\n\n\n  create(documentRef, data) {\n    this.writeBatch.create(documentRef, data);\n    return this.processOperation(documentRef);\n  }\n  /**\n   * Adds a `delete` operation to the WriteBatch. Returns a promise that\n   * resolves with the result of the delete.\n   */\n\n\n  delete(documentRef, precondition) {\n    this.writeBatch.delete(documentRef, precondition);\n    return this.processOperation(documentRef);\n  }\n  /**\n   * Adds a `set` operation to the WriteBatch. Returns a promise that\n   * resolves with the result of the write.\n   */\n\n\n  set(documentRef, data, options) {\n    this.writeBatch.set(documentRef, data, options);\n    return this.processOperation(documentRef);\n  }\n  /**\n   * Adds an `update` operation to the WriteBatch. Returns a promise that\n   * resolves with the result of the write.\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    this.writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n    return this.processOperation(documentRef);\n  }\n  /**\n   * Helper to update data structures associated with the operation and\n   * return the result.\n   */\n\n\n  processOperation(documentRef) {\n    assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n    assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n    this.docPaths.add(documentRef.path);\n    const deferred = new util_1.Deferred();\n    this.resultsMap.set(this.opCount, deferred);\n\n    if (this.opCount === this.maxBatchSize) {\n      this.state = BatchState.READY_TO_SEND;\n    }\n\n    return deferred.promise.then(result => {\n      if (result.writeTime) {\n        return new write_batch_1.WriteResult(result.writeTime);\n      } else {\n        throw result.status;\n      }\n    });\n  }\n  /**\n   * Commits the batch and returns a promise that resolves with the result of\n   * all writes in this batch.\n   */\n\n\n  bulkCommit() {\n    assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n    this.state = BatchState.SENT;\n    return this.writeBatch.bulkCommit();\n  }\n  /**\n   * Resolves the individual operations in the batch with the results.\n   */\n\n\n  processResults(results, error) {\n    if (error === undefined) {\n      for (let i = 0; i < this.opCount; i++) {\n        this.resultsMap.get(i).resolve(results[i]);\n      }\n    } else {\n      for (let i = 0; i < this.opCount; i++) {\n        this.resultsMap.get(i).reject(error);\n      }\n    }\n\n    this.completedDeferred.resolve();\n  }\n  /**\n   * Returns a promise that resolves when the batch has been sent, and a\n   * response is received.\n   */\n\n\n  awaitBulkCommit() {\n    this.markReadyToSend();\n    return this.completedDeferred.promise;\n  }\n\n  markReadyToSend() {\n    if (this.state === BatchState.OPEN) {\n      this.state = BatchState.READY_TO_SEND;\n    }\n  }\n\n}\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n * @private\n */\n\n\nclass BulkWriter {\n  constructor(firestore, enableThrottling) {\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     */\n\n    this.maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * A queue of batches to be written.\n     */\n\n    this.batchQueue = [];\n    /**\n     * Whether this BulkWriter instance is closed. Once closed, it cannot be\n     * opened again.\n     */\n\n    this.closed = false;\n\n    if (enableThrottling) {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n    } else {\n      this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n  }\n  /**\n   * Create a document with the provided data. This single operation will fail\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .create(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  create(documentRef, data) {\n    this.verifyNotClosed();\n    const bulkCommitBatch = this.getEligibleBatch(documentRef);\n    const resultPromise = bulkCommitBatch.create(documentRef, data);\n    this.sendReadyBatches();\n    return resultPromise;\n  }\n  /**\n   * Delete a document from the database.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the batch if the\n   * document doesn't exist or was last updated at a different time.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * bulkWriter\n   *  .delete(documentRef)\n   *  .then(result => {\n   *    console.log('Successfully deleted document at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Delete failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  delete(documentRef, precondition) {\n    this.verifyNotClosed();\n    const bulkCommitBatch = this.getEligibleBatch(documentRef);\n    const resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n    this.sendReadyBatches();\n    return resultPromise;\n  }\n  /**\n   * Write to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document does not\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n   * the provided data can be merged into the existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {T} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call remain\n   * untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n   * only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * bulkWriter\n   *  .set(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  set(documentRef, data, options) {\n    this.verifyNotClosed();\n    const bulkCommitBatch = this.getEligibleBatch(documentRef);\n    const resultPromise = bulkCommitBatch.set(documentRef, data, options);\n    this.sendReadyBatches();\n    return resultPromise;\n  }\n  /**\n   * Update fields of the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n   * exist, the update fails and the entire batch will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n   * alternating list of field paths and values to update or a Precondition to\n   * restrict this update\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\n   * the write. Throws an error if the write fails.\n   *\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * bulkWriter\n   *  .update(documentRef, {foo: 'bar'})\n   *  .then(result => {\n   *    console.log('Successfully executed write at: ', result);\n   *  })\n   *  .catch(err => {\n   *    console.log('Write failed with: ', err);\n   *  });\n   * });\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    this.verifyNotClosed();\n    const bulkCommitBatch = this.getEligibleBatch(documentRef);\n    const resultPromise = bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n    this.sendReadyBatches();\n    return resultPromise;\n  }\n  /**\n   * Commits all writes that have been enqueued up to this point in parallel.\n   *\n   * Returns a Promise that resolves when all currently queued operations have\n   * been committed. The Promise will never be rejected since the results for\n   * each individual operation are conveyed via their individual Promises.\n   *\n   * The Promise resolves immediately if there are no pending writes. Otherwise,\n   * the Promise waits for all previously issued writes, but it does not wait\n   * for writes that were added after the method is called. If you want to wait\n   * for additional writes, call `flush()` again.\n   *\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\n   * up to this point have been committed.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter.create(documentRef, {foo: 'bar'});\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\n   * bulkWriter.delete(documentRef3);\n   * await flush().then(() => {\n   *   console.log('Executed all writes');\n   * });\n   */\n\n\n  async flush() {\n    this.verifyNotClosed();\n    const trackedBatches = this.batchQueue;\n    const writePromises = trackedBatches.map(batch => batch.awaitBulkCommit());\n    this.sendReadyBatches();\n    await Promise.all(writePromises);\n  }\n  /**\n   * Commits all enqueued writes and marks the BulkWriter instance as closed.\n   *\n   * After calling `close()`, calling any method wil throw an error.\n   *\n   * Returns a Promise that resolves when there are no more pending writes. The\n   * Promise will never be rejected. Calling this method will send all requests.\n   * The promise resolves immediately if there are no pending writes.\n   *\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\n   * up to this point have been committed.\n   *\n   * @example\n   * let bulkWriter = firestore.bulkWriter();\n   *\n   * bulkWriter.create(documentRef, {foo: 'bar'});\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\n   * bulkWriter.delete(documentRef3);\n   * await close().then(() => {\n   *   console.log('Executed all writes');\n   * });\n   */\n\n\n  close() {\n    const flushPromise = this.flush();\n    this.closed = true;\n    return flushPromise;\n  }\n\n  verifyNotClosed() {\n    if (this.closed) {\n      throw new Error('BulkWriter has already been closed.');\n    }\n  }\n  /**\n   * Return the first eligible batch that can hold a write to the provided\n   * reference, or creates one if no eligible batches are found.\n   *\n   * @private\n   */\n\n\n  getEligibleBatch(ref) {\n    if (this.batchQueue.length > 0) {\n      const lastBatch = this.batchQueue[this.batchQueue.length - 1];\n\n      if (lastBatch.state === BatchState.OPEN && !lastBatch.docPaths.has(ref.path)) {\n        return lastBatch;\n      }\n    }\n\n    return this.createNewBatch();\n  }\n  /**\n   * Creates a new batch and adds it to the BatchQueue. If there is already a\n   * batch enqueued, sends the batch after a new one is created.\n   *\n   * @private\n   */\n\n\n  createNewBatch() {\n    const newBatch = new BulkCommitBatch(this.firestore.batch(), this.maxBatchSize);\n\n    if (this.batchQueue.length > 0) {\n      this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n      this.sendReadyBatches();\n    }\n\n    this.batchQueue.push(newBatch);\n    return newBatch;\n  }\n  /**\n   * Attempts to send batches starting from the front of the BatchQueue until a\n   * batch cannot be sent.\n   *\n   * After a batch is complete, try sending batches again.\n   *\n   * @private\n   */\n\n\n  sendReadyBatches() {\n    const unsentBatches = this.batchQueue.filter(batch => batch.state === BatchState.READY_TO_SEND);\n    let index = 0;\n\n    while (index < unsentBatches.length && this.isBatchSendable(unsentBatches[index])) {\n      const batch = unsentBatches[index]; // Send the batch if it is under the rate limit, or schedule another\n      // attempt after the appropriate timeout.\n\n      const delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n      assert(delayMs !== -1, 'Batch size should be under capacity');\n\n      if (delayMs === 0) {\n        this.sendBatch(batch);\n      } else {\n        backoff_1.delayExecution(() => this.sendReadyBatches(), delayMs);\n        break;\n      }\n\n      index++;\n    }\n  }\n  /**\n   * Sends the provided batch and processes the results. After the batch is\n   * committed, sends the next group of ready batches.\n   *\n   * @private\n   */\n\n\n  sendBatch(batch) {\n    const success = this.rateLimiter.tryMakeRequest(batch.opCount);\n    assert(success, 'Batch should be under rate limit to be sent.');\n    batch.bulkCommit().then(results => {\n      batch.processResults(results);\n    }).catch(error => {\n      batch.processResults([], error);\n    }).then(() => {\n      // Remove the batch from the BatchQueue after it has been processed.\n      const batchIndex = this.batchQueue.indexOf(batch);\n      assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n      this.batchQueue.splice(batchIndex, 1);\n      this.sendReadyBatches();\n    });\n  }\n  /**\n   * Checks that the provided batch is sendable. To be sendable, a batch must:\n   * (1) be marked as READY_TO_SEND\n   * (2) not write to references that are currently in flight\n   *\n   * @private\n   */\n\n\n  isBatchSendable(batch) {\n    if (batch.state !== BatchState.READY_TO_SEND) {\n      return false;\n    }\n\n    for (const path of batch.docPaths) {\n      const isRefInFlight = this.batchQueue.filter(batch => batch.state === BatchState.SENT).find(batch => batch.docPaths.has(path)) !== undefined;\n\n      if (isRefInFlight) {\n        console.warn('[BulkWriter]', `Duplicate write to document \"${path}\" detected.`, 'Writing to the same document multiple times will slow down BulkWriter. ' + 'Write to unique documents in order to maximize throughput.');\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Sets the maximum number of allowed operations in a batch.\n   *\n   * @private\n   */\n  // Visible for testing.\n\n\n  _setMaxBatchSize(size) {\n    this.maxBatchSize = size;\n  }\n\n}\n\nexports.BulkWriter = BulkWriter;","map":{"version":3,"sources":["/Users/suya/Desktop/front end study/webProjects/shopping-cart/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","assert","require","backoff_1","rate_limiter_1","util_1","write_batch_1","MAX_BATCH_SIZE","STARTING_MAXIMUM_OPS_PER_SECOND","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","BatchState","BulkCommitBatch","constructor","writeBatch","maxBatchSize","state","OPEN","docPaths","Set","completedDeferred","Deferred","resultsMap","Map","opCount","size","create","documentRef","data","processOperation","delete","precondition","set","options","update","dataOrField","preconditionOrValues","has","path","add","deferred","READY_TO_SEND","promise","then","result","writeTime","WriteResult","status","bulkCommit","SENT","processResults","results","error","undefined","i","get","resolve","reject","awaitBulkCommit","markReadyToSend","BulkWriter","firestore","enableThrottling","batchQueue","closed","rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","verifyNotClosed","bulkCommitBatch","getEligibleBatch","resultPromise","sendReadyBatches","flush","trackedBatches","writePromises","map","batch","Promise","all","close","flushPromise","Error","ref","length","lastBatch","createNewBatch","newBatch","push","unsentBatches","filter","index","isBatchSendable","delayMs","getNextRequestDelayMs","sendBatch","delayExecution","success","tryMakeRequest","catch","batchIndex","indexOf","splice","isRefInFlight","find","console","warn","_setMaxBatchSize"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;;;;;;;;;;;;;;;;AAeA,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,eAAD,CAA7B;AACA;;;;;AAGA,MAAMK,cAAc,GAAG,GAAvB;AACA;;;;;;;AAMA,MAAMC,+BAA+B,GAAG,GAAxC;AACA;;;;;;AAKA,MAAMC,uBAAuB,GAAG,GAAhC;AACA;;;;;;;AAMA,MAAMC,8BAA8B,GAAG,IAAI,EAAJ,GAAS,IAAhD;AACA;;;;;;;AAMA,IAAIC,UAAJ;;AACA,CAAC,UAAUA,UAAV,EAAsB;AACnBA,EAAAA,UAAU,CAACA,UAAU,CAAC,MAAD,CAAV,GAAqB,CAAtB,CAAV,GAAqC,MAArC;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,eAAD,CAAV,GAA8B,CAA/B,CAAV,GAA8C,eAA9C;AACAA,EAAAA,UAAU,CAACA,UAAU,CAAC,MAAD,CAAV,GAAqB,CAAtB,CAAV,GAAqC,MAArC;AACH,CAJD,EAIGA,UAAU,KAAKA,UAAU,GAAG,EAAlB,CAJb;AAKA;;;;;;;AAKA,MAAMC,eAAN,CAAsB;AAClBC,EAAAA,WAAW,CAACC,UAAD,EAAaC,YAAb,EAA2B;AAClC,SAAKD,UAAL,GAAkBA,UAAlB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA;;;;AAGA,SAAKC,KAAL,GAAaL,UAAU,CAACM,IAAxB,CANkC,CAOlC;;AACA,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB,CARkC,CASlC;AACA;;AACA,SAAKC,iBAAL,GAAyB,IAAIf,MAAM,CAACgB,QAAX,EAAzB,CAXkC,CAYlC;;AACA,SAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACH;AACD;;;;;AAGA,MAAIC,OAAJ,GAAc;AACV,WAAO,KAAKF,UAAL,CAAgBG,IAAvB;AACH;AACD;;;;;;AAIAC,EAAAA,MAAM,CAACC,WAAD,EAAcC,IAAd,EAAoB;AACtB,SAAKd,UAAL,CAAgBY,MAAhB,CAAuBC,WAAvB,EAAoCC,IAApC;AACA,WAAO,KAAKC,gBAAL,CAAsBF,WAAtB,CAAP;AACH;AACD;;;;;;AAIAG,EAAAA,MAAM,CAACH,WAAD,EAAcI,YAAd,EAA4B;AAC9B,SAAKjB,UAAL,CAAgBgB,MAAhB,CAAuBH,WAAvB,EAAoCI,YAApC;AACA,WAAO,KAAKF,gBAAL,CAAsBF,WAAtB,CAAP;AACH;AACD;;;;;;AAIAK,EAAAA,GAAG,CAACL,WAAD,EAAcC,IAAd,EAAoBK,OAApB,EAA6B;AAC5B,SAAKnB,UAAL,CAAgBkB,GAAhB,CAAoBL,WAApB,EAAiCC,IAAjC,EAAuCK,OAAvC;AACA,WAAO,KAAKJ,gBAAL,CAAsBF,WAAtB,CAAP;AACH;AACD;;;;;;AAIAO,EAAAA,MAAM,CAACP,WAAD,EAAcQ,WAAd,EAA2B,GAAGC,oBAA9B,EAAoD;AACtD,SAAKtB,UAAL,CAAgBoB,MAAhB,CAAuBP,WAAvB,EAAoCQ,WAApC,EAAiD,GAAGC,oBAApD;AACA,WAAO,KAAKP,gBAAL,CAAsBF,WAAtB,CAAP;AACH;AACD;;;;;;AAIAE,EAAAA,gBAAgB,CAACF,WAAD,EAAc;AAC1B1B,IAAAA,MAAM,CAAC,CAAC,KAAKiB,QAAL,CAAcmB,GAAd,CAAkBV,WAAW,CAACW,IAA9B,CAAF,EAAuC,sDAAvC,CAAN;AACArC,IAAAA,MAAM,CAAC,KAAKe,KAAL,KAAeL,UAAU,CAACM,IAA3B,EAAiC,yCAAjC,CAAN;AACA,SAAKC,QAAL,CAAcqB,GAAd,CAAkBZ,WAAW,CAACW,IAA9B;AACA,UAAME,QAAQ,GAAG,IAAInC,MAAM,CAACgB,QAAX,EAAjB;AACA,SAAKC,UAAL,CAAgBU,GAAhB,CAAoB,KAAKR,OAAzB,EAAkCgB,QAAlC;;AACA,QAAI,KAAKhB,OAAL,KAAiB,KAAKT,YAA1B,EAAwC;AACpC,WAAKC,KAAL,GAAaL,UAAU,CAAC8B,aAAxB;AACH;;AACD,WAAOD,QAAQ,CAACE,OAAT,CAAiBC,IAAjB,CAAsBC,MAAM,IAAI;AACnC,UAAIA,MAAM,CAACC,SAAX,EAAsB;AAClB,eAAO,IAAIvC,aAAa,CAACwC,WAAlB,CAA8BF,MAAM,CAACC,SAArC,CAAP;AACH,OAFD,MAGK;AACD,cAAMD,MAAM,CAACG,MAAb;AACH;AACJ,KAPM,CAAP;AAQH;AACD;;;;;;AAIAC,EAAAA,UAAU,GAAG;AACT/C,IAAAA,MAAM,CAAC,KAAKe,KAAL,KAAeL,UAAU,CAAC8B,aAA3B,EAA0C,+DAA1C,CAAN;AACA,SAAKzB,KAAL,GAAaL,UAAU,CAACsC,IAAxB;AACA,WAAO,KAAKnC,UAAL,CAAgBkC,UAAhB,EAAP;AACH;AACD;;;;;AAGAE,EAAAA,cAAc,CAACC,OAAD,EAAUC,KAAV,EAAiB;AAC3B,QAAIA,KAAK,KAAKC,SAAd,EAAyB;AACrB,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK9B,OAAzB,EAAkC8B,CAAC,EAAnC,EAAuC;AACnC,aAAKhC,UAAL,CAAgBiC,GAAhB,CAAoBD,CAApB,EAAuBE,OAAvB,CAA+BL,OAAO,CAACG,CAAD,CAAtC;AACH;AACJ,KAJD,MAKK;AACD,WAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK9B,OAAzB,EAAkC8B,CAAC,EAAnC,EAAuC;AACnC,aAAKhC,UAAL,CAAgBiC,GAAhB,CAAoBD,CAApB,EAAuBG,MAAvB,CAA8BL,KAA9B;AACH;AACJ;;AACD,SAAKhC,iBAAL,CAAuBoC,OAAvB;AACH;AACD;;;;;;AAIAE,EAAAA,eAAe,GAAG;AACd,SAAKC,eAAL;AACA,WAAO,KAAKvC,iBAAL,CAAuBsB,OAA9B;AACH;;AACDiB,EAAAA,eAAe,GAAG;AACd,QAAI,KAAK3C,KAAL,KAAeL,UAAU,CAACM,IAA9B,EAAoC;AAChC,WAAKD,KAAL,GAAaL,UAAU,CAAC8B,aAAxB;AACH;AACJ;;AAjHiB;AAmHtB;;;;;;;;;AAOA,MAAMmB,UAAN,CAAiB;AACb/C,EAAAA,WAAW,CAACgD,SAAD,EAAYC,gBAAZ,EAA8B;AACrC,SAAKD,SAAL,GAAiBA,SAAjB;AACA;;;;AAGA,SAAK9C,YAAL,GAAoBR,cAApB;AACA;;;;AAGA,SAAKwD,UAAL,GAAkB,EAAlB;AACA;;;;;AAIA,SAAKC,MAAL,GAAc,KAAd;;AACA,QAAIF,gBAAJ,EAAsB;AAClB,WAAKG,WAAL,GAAmB,IAAI7D,cAAc,CAAC8D,WAAnB,CAA+B1D,+BAA/B,EAAgEC,uBAAhE,EAAyFC,8BAAzF,CAAnB;AACH,KAFD,MAGK;AACD,WAAKuD,WAAL,GAAmB,IAAI7D,cAAc,CAAC8D,WAAnB,CAA+BC,MAAM,CAACC,iBAAtC,EAAyDD,MAAM,CAACC,iBAAhE,EAAmFD,MAAM,CAACC,iBAA1F,CAAnB;AACH;AACJ;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA1C,EAAAA,MAAM,CAACC,WAAD,EAAcC,IAAd,EAAoB;AACtB,SAAKyC,eAAL;AACA,UAAMC,eAAe,GAAG,KAAKC,gBAAL,CAAsB5C,WAAtB,CAAxB;AACA,UAAM6C,aAAa,GAAGF,eAAe,CAAC5C,MAAhB,CAAuBC,WAAvB,EAAoCC,IAApC,CAAtB;AACA,SAAK6C,gBAAL;AACA,WAAOD,aAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA1C,EAAAA,MAAM,CAACH,WAAD,EAAcI,YAAd,EAA4B;AAC9B,SAAKsC,eAAL;AACA,UAAMC,eAAe,GAAG,KAAKC,gBAAL,CAAsB5C,WAAtB,CAAxB;AACA,UAAM6C,aAAa,GAAGF,eAAe,CAACxC,MAAhB,CAAuBH,WAAvB,EAAoCI,YAApC,CAAtB;AACA,SAAK0C,gBAAL;AACA,WAAOD,aAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCAxC,EAAAA,GAAG,CAACL,WAAD,EAAcC,IAAd,EAAoBK,OAApB,EAA6B;AAC5B,SAAKoC,eAAL;AACA,UAAMC,eAAe,GAAG,KAAKC,gBAAL,CAAsB5C,WAAtB,CAAxB;AACA,UAAM6C,aAAa,GAAGF,eAAe,CAACtC,GAAhB,CAAoBL,WAApB,EAAiCC,IAAjC,EAAuCK,OAAvC,CAAtB;AACA,SAAKwC,gBAAL;AACA,WAAOD,aAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCAtC,EAAAA,MAAM,CAACP,WAAD,EAAcQ,WAAd,EAA2B,GAAGC,oBAA9B,EAAoD;AACtD,SAAKiC,eAAL;AACA,UAAMC,eAAe,GAAG,KAAKC,gBAAL,CAAsB5C,WAAtB,CAAxB;AACA,UAAM6C,aAAa,GAAGF,eAAe,CAACpC,MAAhB,CAAuBP,WAAvB,EAAoCQ,WAApC,EAAiD,GAAGC,oBAApD,CAAtB;AACA,SAAKqC,gBAAL;AACA,WAAOD,aAAP;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,QAAME,KAAN,GAAc;AACV,SAAKL,eAAL;AACA,UAAMM,cAAc,GAAG,KAAKZ,UAA5B;AACA,UAAMa,aAAa,GAAGD,cAAc,CAACE,GAAf,CAAmBC,KAAK,IAAIA,KAAK,CAACpB,eAAN,EAA5B,CAAtB;AACA,SAAKe,gBAAL;AACA,UAAMM,OAAO,CAACC,GAAR,CAAYJ,aAAZ,CAAN;AACH;AACD;;;;;;;;;;;;;;;;;;;;;;;;AAsBAK,EAAAA,KAAK,GAAG;AACJ,UAAMC,YAAY,GAAG,KAAKR,KAAL,EAArB;AACA,SAAKV,MAAL,GAAc,IAAd;AACA,WAAOkB,YAAP;AACH;;AACDb,EAAAA,eAAe,GAAG;AACd,QAAI,KAAKL,MAAT,EAAiB;AACb,YAAM,IAAImB,KAAJ,CAAU,qCAAV,CAAN;AACH;AACJ;AACD;;;;;;;;AAMAZ,EAAAA,gBAAgB,CAACa,GAAD,EAAM;AAClB,QAAI,KAAKrB,UAAL,CAAgBsB,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,YAAMC,SAAS,GAAG,KAAKvB,UAAL,CAAgB,KAAKA,UAAL,CAAgBsB,MAAhB,GAAyB,CAAzC,CAAlB;;AACA,UAAIC,SAAS,CAACtE,KAAV,KAAoBL,UAAU,CAACM,IAA/B,IACA,CAACqE,SAAS,CAACpE,QAAV,CAAmBmB,GAAnB,CAAuB+C,GAAG,CAAC9C,IAA3B,CADL,EACuC;AACnC,eAAOgD,SAAP;AACH;AACJ;;AACD,WAAO,KAAKC,cAAL,EAAP;AACH;AACD;;;;;;;;AAMAA,EAAAA,cAAc,GAAG;AACb,UAAMC,QAAQ,GAAG,IAAI5E,eAAJ,CAAoB,KAAKiD,SAAL,CAAeiB,KAAf,EAApB,EAA4C,KAAK/D,YAAjD,CAAjB;;AACA,QAAI,KAAKgD,UAAL,CAAgBsB,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,WAAKtB,UAAL,CAAgB,KAAKA,UAAL,CAAgBsB,MAAhB,GAAyB,CAAzC,EAA4C1B,eAA5C;AACA,WAAKc,gBAAL;AACH;;AACD,SAAKV,UAAL,CAAgB0B,IAAhB,CAAqBD,QAArB;AACA,WAAOA,QAAP;AACH;AACD;;;;;;;;;;AAQAf,EAAAA,gBAAgB,GAAG;AACf,UAAMiB,aAAa,GAAG,KAAK3B,UAAL,CAAgB4B,MAAhB,CAAuBb,KAAK,IAAIA,KAAK,CAAC9D,KAAN,KAAgBL,UAAU,CAAC8B,aAA3D,CAAtB;AACA,QAAImD,KAAK,GAAG,CAAZ;;AACA,WAAOA,KAAK,GAAGF,aAAa,CAACL,MAAtB,IACH,KAAKQ,eAAL,CAAqBH,aAAa,CAACE,KAAD,CAAlC,CADJ,EACgD;AAC5C,YAAMd,KAAK,GAAGY,aAAa,CAACE,KAAD,CAA3B,CAD4C,CAE5C;AACA;;AACA,YAAME,OAAO,GAAG,KAAK7B,WAAL,CAAiB8B,qBAAjB,CAAuCjB,KAAK,CAACtD,OAA7C,CAAhB;AACAvB,MAAAA,MAAM,CAAC6F,OAAO,KAAK,CAAC,CAAd,EAAiB,qCAAjB,CAAN;;AACA,UAAIA,OAAO,KAAK,CAAhB,EAAmB;AACf,aAAKE,SAAL,CAAelB,KAAf;AACH,OAFD,MAGK;AACD3E,QAAAA,SAAS,CAAC8F,cAAV,CAAyB,MAAM,KAAKxB,gBAAL,EAA/B,EAAwDqB,OAAxD;AACA;AACH;;AACDF,MAAAA,KAAK;AACR;AACJ;AACD;;;;;;;;AAMAI,EAAAA,SAAS,CAAClB,KAAD,EAAQ;AACb,UAAMoB,OAAO,GAAG,KAAKjC,WAAL,CAAiBkC,cAAjB,CAAgCrB,KAAK,CAACtD,OAAtC,CAAhB;AACAvB,IAAAA,MAAM,CAACiG,OAAD,EAAU,8CAAV,CAAN;AACApB,IAAAA,KAAK,CACA9B,UADL,GAEKL,IAFL,CAEUQ,OAAO,IAAI;AACjB2B,MAAAA,KAAK,CAAC5B,cAAN,CAAqBC,OAArB;AACH,KAJD,EAKKiD,KALL,CAKYhD,KAAD,IAAW;AAClB0B,MAAAA,KAAK,CAAC5B,cAAN,CAAqB,EAArB,EAAyBE,KAAzB;AACH,KAPD,EAQKT,IARL,CAQU,MAAM;AACZ;AACA,YAAM0D,UAAU,GAAG,KAAKtC,UAAL,CAAgBuC,OAAhB,CAAwBxB,KAAxB,CAAnB;AACA7E,MAAAA,MAAM,CAACoG,UAAU,KAAK,CAAC,CAAjB,EAAoB,uCAApB,CAAN;AACA,WAAKtC,UAAL,CAAgBwC,MAAhB,CAAuBF,UAAvB,EAAmC,CAAnC;AACA,WAAK5B,gBAAL;AACH,KAdD;AAeH;AACD;;;;;;;;;AAOAoB,EAAAA,eAAe,CAACf,KAAD,EAAQ;AACnB,QAAIA,KAAK,CAAC9D,KAAN,KAAgBL,UAAU,CAAC8B,aAA/B,EAA8C;AAC1C,aAAO,KAAP;AACH;;AACD,SAAK,MAAMH,IAAX,IAAmBwC,KAAK,CAAC5D,QAAzB,EAAmC;AAC/B,YAAMsF,aAAa,GAAG,KAAKzC,UAAL,CACjB4B,MADiB,CACVb,KAAK,IAAIA,KAAK,CAAC9D,KAAN,KAAgBL,UAAU,CAACsC,IAD1B,EAEjBwD,IAFiB,CAEZ3B,KAAK,IAAIA,KAAK,CAAC5D,QAAN,CAAemB,GAAf,CAAmBC,IAAnB,CAFG,MAE2Be,SAFjD;;AAGA,UAAImD,aAAJ,EAAmB;AACfE,QAAAA,OAAO,CAACC,IAAR,CAAa,cAAb,EAA8B,gCAA+BrE,IAAK,aAAlE,EAAgF,4EAC5E,4DADJ;AAEA,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;AACD;;;;;AAKA;;;AACAsE,EAAAA,gBAAgB,CAACnF,IAAD,EAAO;AACnB,SAAKV,YAAL,GAAoBU,IAApB;AACH;;AApWY;;AAsWjB1B,OAAO,CAAC6D,UAAR,GAAqBA,UAArB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 500;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\nvar BatchState;\n(function (BatchState) {\n    BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n    BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n    BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch {\n    constructor(writeBatch, maxBatchSize) {\n        this.writeBatch = writeBatch;\n        this.maxBatchSize = maxBatchSize;\n        /**\n         * The state of the batch.\n         */\n        this.state = BatchState.OPEN;\n        // The set of document reference paths present in the WriteBatch.\n        this.docPaths = new Set();\n        // A deferred promise that is resolved after the batch has been sent, and a\n        // response is received.\n        this.completedDeferred = new util_1.Deferred();\n        // A map from each WriteBatch operation to its corresponding result.\n        this.resultsMap = new Map();\n    }\n    /**\n     * The number of writes in this batch.\n     */\n    get opCount() {\n        return this.resultsMap.size;\n    }\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    create(documentRef, data) {\n        this.writeBatch.create(documentRef, data);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the delete.\n     */\n    delete(documentRef, precondition) {\n        this.writeBatch.delete(documentRef, precondition);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    set(documentRef, data, options) {\n        this.writeBatch.set(documentRef, data, options);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n    processOperation(documentRef) {\n        assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n        assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n        this.docPaths.add(documentRef.path);\n        const deferred = new util_1.Deferred();\n        this.resultsMap.set(this.opCount, deferred);\n        if (this.opCount === this.maxBatchSize) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n        return deferred.promise.then(result => {\n            if (result.writeTime) {\n                return new write_batch_1.WriteResult(result.writeTime);\n            }\n            else {\n                throw result.status;\n            }\n        });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves with the result of\n     * all writes in this batch.\n     */\n    bulkCommit() {\n        assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n        this.state = BatchState.SENT;\n        return this.writeBatch.bulkCommit();\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n    processResults(results, error) {\n        if (error === undefined) {\n            for (let i = 0; i < this.opCount; i++) {\n                this.resultsMap.get(i).resolve(results[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < this.opCount; i++) {\n                this.resultsMap.get(i).reject(error);\n            }\n        }\n        this.completedDeferred.resolve();\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n    awaitBulkCommit() {\n        this.markReadyToSend();\n        return this.completedDeferred.promise;\n    }\n    markReadyToSend() {\n        if (this.state === BatchState.OPEN) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n    }\n}\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n * @private\n */\nclass BulkWriter {\n    constructor(firestore, enableThrottling) {\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         */\n        this.maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * A queue of batches to be written.\n         */\n        this.batchQueue = [];\n        /**\n         * Whether this BulkWriter instance is closed. Once closed, it cannot be\n         * opened again.\n         */\n        this.closed = false;\n        if (enableThrottling) {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n        }\n        else {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.create(documentRef, data);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.set(documentRef, data, options);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    async flush() {\n        this.verifyNotClosed();\n        const trackedBatches = this.batchQueue;\n        const writePromises = trackedBatches.map(batch => batch.awaitBulkCommit());\n        this.sendReadyBatches();\n        await Promise.all(writePromises);\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        const flushPromise = this.flush();\n        this.closed = true;\n        return flushPromise;\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n    getEligibleBatch(ref) {\n        if (this.batchQueue.length > 0) {\n            const lastBatch = this.batchQueue[this.batchQueue.length - 1];\n            if (lastBatch.state === BatchState.OPEN &&\n                !lastBatch.docPaths.has(ref.path)) {\n                return lastBatch;\n            }\n        }\n        return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n    createNewBatch() {\n        const newBatch = new BulkCommitBatch(this.firestore.batch(), this.maxBatchSize);\n        if (this.batchQueue.length > 0) {\n            this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n            this.sendReadyBatches();\n        }\n        this.batchQueue.push(newBatch);\n        return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n    sendReadyBatches() {\n        const unsentBatches = this.batchQueue.filter(batch => batch.state === BatchState.READY_TO_SEND);\n        let index = 0;\n        while (index < unsentBatches.length &&\n            this.isBatchSendable(unsentBatches[index])) {\n            const batch = unsentBatches[index];\n            // Send the batch if it is under the rate limit, or schedule another\n            // attempt after the appropriate timeout.\n            const delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n            assert(delayMs !== -1, 'Batch size should be under capacity');\n            if (delayMs === 0) {\n                this.sendBatch(batch);\n            }\n            else {\n                backoff_1.delayExecution(() => this.sendReadyBatches(), delayMs);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n    sendBatch(batch) {\n        const success = this.rateLimiter.tryMakeRequest(batch.opCount);\n        assert(success, 'Batch should be under rate limit to be sent.');\n        batch\n            .bulkCommit()\n            .then(results => {\n            batch.processResults(results);\n        })\n            .catch((error) => {\n            batch.processResults([], error);\n        })\n            .then(() => {\n            // Remove the batch from the BatchQueue after it has been processed.\n            const batchIndex = this.batchQueue.indexOf(batch);\n            assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n            this.batchQueue.splice(batchIndex, 1);\n            this.sendReadyBatches();\n        });\n    }\n    /**\n     * Checks that the provided batch is sendable. To be sendable, a batch must:\n     * (1) be marked as READY_TO_SEND\n     * (2) not write to references that are currently in flight\n     *\n     * @private\n     */\n    isBatchSendable(batch) {\n        if (batch.state !== BatchState.READY_TO_SEND) {\n            return false;\n        }\n        for (const path of batch.docPaths) {\n            const isRefInFlight = this.batchQueue\n                .filter(batch => batch.state === BatchState.SENT)\n                .find(batch => batch.docPaths.has(path)) !== undefined;\n            if (isRefInFlight) {\n                console.warn('[BulkWriter]', `Duplicate write to document \"${path}\" detected.`, 'Writing to the same document multiple times will slow down BulkWriter. ' +\n                    'Write to unique documents in order to maximize throughput.');\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        this.maxBatchSize = size;\n    }\n}\nexports.BulkWriter = BulkWriter;\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}